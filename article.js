// Чи все ви знаєте про функції?

// Ця стаття надає зрозуміле уявлення про функції в контексті мови програмування JavaScript. Вона розбирається з різними видами функцій, їх ролями та впливом на структуру програм, а також визначає принципові відмінності між ними. Давайте поринемо у світ функцій і розкриємо їх роль у створенні ефективного та організованого коду.


// Зміст статті

// 1. Що таке функція?

// 2. Види функції (декларації та вирази)

// 3. Звичайні та Стрілочні функції

// 5. Callback

// 6. Анонімні функції

// 7. Асинхронні функції

// 8. Функції - генератори

// Що таке функція?

// У JavaScript функція - це блок коду (підпрограмма), який може бути визначений для виконання конкретної задачі. Функції є фундаментальним будівельним блоком JavaScript. Самі ж функції складаються з послідовності існтрукцій (тіла функції). Будь яка функція є обʼєктом і має свої властивості і методи.

// Спочатку згадаємо з чого складається функція:
// (цей блок прям для дошколят)

// - Імʼя функціі (Function name)
// Функції можуть мати імена які використовуються для їхнього виклику. Наприклад:

function sayHi() {
  console.log("Hello world!")
}

// - Параметри (Parameters):
// Функції можуть приймати характеристики, які є значеннями, що передаються під час виклику функції. Параметри вказуються в дужках при оголошенні функції та використовуються усередині тіла функції. Наприклад:

function sayHi(name) {
  console.log(`Hello,  ${name}!`)
}

// - Тіло функції (Function Body):
// Це саме і є той блок коду, який знаходиться між фігурними дужками{}. Всередині тіла функції визначені операції, які будуть виконуватися при її виклику. В прикладі вище, тілом функції є  console.log(`Hello,  ${name}!`

// Значення, що повертається (Return Value):
// Функція може повертати значення за допомогою оператора return. Це значення передається назад у ділянку коду, який викликав функцію. Наприклад:

function double(x) {
  return x * 2;
}

const result = double(2)
console.log(result) // 4

// - Виклик функції (Function Invocation):

// Це місце у коді, де функція фактично викликається, і їй передаються необхідні аргументи (якщо вони є). Наприклад:

sayHi("John") // Hello, John!


// Види функцій

// Функції-декларації (function declaration)

// Функція-декларація - це функція, яка підіймється вгору в початок контексту блоку, в якому вона була оголошена. Така функція оголошується за допомогою ключового слова function. За рахунок цього вона може бути викликана до її оголошення.

// Разберемо подробно:

// Що означає «Підіймається вгору» ?
// Справа в тому, що інтерпретатор JavaScript виконує прохід по коду двічі. В момент першого проходу, він реєструє в памʼяті імена змінних, в тому числі тих, яким було присвоєні функції, але не реєструє їх значення*. Під час другого проходу він присвоює значення цім змінним і викликає їх. Але функції-декларації реєструються повністю, разом з тілом функції, таким чином, під час другого проходу вони вже є в памʼяті. І саме за рахунок цього ми можемо викликати такі функції до їх оголошення.

// * Окрім змінних, оголошених за допомогою ключового слова var. Таким змінним в момент першого проходу присвоюється значення undefined, а також вони спливають вгору глобальної області видимості. Але ця стаття зовсім не про var, тому на це поки що не треба звертати увагу.

// Уважно ознайомтесь з прикладом:

myFirstFunction() // Hello (Функція зареєстрована разом з тілом під час першого проходу, тому вона доступна до виклику)

mySecondFunction() // Error: Cannot access 'SecondFunction' before initialization (Під час першого проходу було зареєстрована тільки назва змінної, без будь якого значення)

myThirdFunction() // Error: myFunction is not a function (Під час першого проходу була зареєстрована змінна, якій було присвоєно значення undefined. undefined – is not a function)

function myFirstFunction() {
console.log("Hello")
}

const mySecondFunction = () => {
	console.log("Hello 2")
}

var myThirdFunction = function() {
	console.log("Hello 3")
}

// Ця подія, яка відбувається під час першого проходу інтрепретатора по коду та реєстрація змінних і функцій називається hoisting(спливання). (Спливання вгору усіх імен змінних та функцій-декларацій)

// Функції-вирази (Function Expression)

// Функції-вирази представляють собою вираз, який присвоюється змінній. Після вищенаписаного не складно здогадатися, що вони не можуть викликатися до їх ініціалізації, бо значення змінної не спливає вгору своєї області видимості під час першого проходу інтерпретатором.

// Функції-вирази можуть бути реалізовані двома способами:

// 1.	За допомогою звичайних функцій
// 2.	За допомогою стрілочних функцій

// Звичайні функції

// Так само, за допомогою ключового слова function ми ініціалізуємо функцію в якості значення змінної:
const myFunction = function() {
	console.log("Hello")
}

// Зверніть увагу, фактично ми записуємо функцію-декларацію в якості значення змінної, але саме через те, що вона записана в змінну, до неї не буде доступу до її оголошення, бо значення змінних не реєструється в момент першого проходу інтерпретатора JavaScript.

// Приведу один цікавий приклад:

sayHello("Kate") // Hello, Kate

helloJohn() // Error: Cannot access ' helloJohn ' before initialization

const helloJohn = sayHello(‘John’)

function sayHello(name) {
	console.log(`Hello, ${name}`)
}

// Стрілочні функції

// Стрілочні функції (Arrow Functions) - це синтаксис введений в ECMAScript 6 (ES6) для визначення функцій в JavaScript. Вони надають більш короткий та зручний спосіб створення функцій, особливо корисний для функцій з одним виразом.

const myFunction = () => {
	console.log("Hello")
}

// Або такі короткі функції можна записувати в одну строчку без фігурних дужок:

const myFunction = () => console.log("Hello")

// Також, якщо стрілоча функція повинна щось повертати, але не виконує якісь складні дії, то якщо вона пишеться в одну строку, можна не використовувати ключове слово return:

const result = (x) => x * 2

// А якщо функція приймає тільки один параметр, то можна взагалі обійтись без дужок:

const result = x => x * 2
// Хтось дізнався щось нове, хтось освіжив памʼять, а тепер розглянемо більш глибокі особливості та ключові відмінності між звичайними і стрілочними функціями, які ви могли не знати.

// Особливості стрілочних функцій
// Контекст (this)

// Поспілкувавшись на цю тему з деякими початківцями, я виявив що не усі знають про відмінність контексту у функціях, а ті, хто знають, то плутаються в термінах, вважаючи що у функцій-декларацій і функцій-виразів this посилається на різні об’єкти.

// В першу чергу що я хочу зробити, так це розділити функції на два види: стрілочні функції та усі інші функції, опустивши при цьому терміни “декларації” та “вирази” взагалі.

// Контекст у звичайних функціях
// this буде залежати від того, де така функція буде викликатися. Абсолютно не має значення це функція-вираз чи функція-декларація. Головне, що мова про усі функції, окрім стрілочних.
// Приклад:

function regularFunction(){
    console.log(this)
}

const obj = {
	method: regularFunction
}

obj.method() // obj (Контекстом є область де функція викликається)
regularFunction() // window (Функція викликається в глобальному обʼєкті)

// Контекст стрілочних функцій
// this буде завжди посилатися на область, в якій ця функція була оголошена, не залежно від того, де вона викликається.
// Приклад:

const arrowFunction = () => {
	console.log(this)
}

const obj = {
	method: arrowFunction
}

obj.method() // window
arrowFunction // window

// В обидвох випадках контекст не буде змінено і залишиться таким, яким він був на момент оголошення функції.

// Робота з аргументами функцій
// Окрім того, що багато хто не знає про ці відмінності, деякі початківці взагалі не знають про те, що в тілі функції можна працювати з аргументами навіть якщо, ми не очікуємо ніяких аргументів при оголошенні функції.

// Аргументи в звичайних функціях
// В звичайних функціях завжди є доступ до масивоподібного обʼєкту arguments, який зберігає в себе усі аргументи, які ми передаємо в функцію.

// Приклад:

const myFunction = function() {
	console.log(arguments)
}

// Викликаємо цю функцію в барузері:
myFunction(1, 2, 3) // [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ] 

// Викликаємо цю функцію в Node.js:
myFunction(1, 2, 3) // [Arguments] { '0': 1, '1': 2, '2': 3 } 

// Не варто звертати увагу на різні результати виклику. Вони залежать від середовища в якому викликаються.
// Ми бачимо, що ми отримали усі аргументи в масивоподібному обʼєкті (псевдомасиві) в браузері, або в звичайному обʼєкті в Node.js, які ми передали в функцію. В браузері також отримуємо додаткові властивості, які в сучасних проектах практично не використовуються, і зупинятися на них я не бачу сенсу.

// Примітка: Оскільки ми отримуємо саме масивоподібний обʼєкт, а не масив, ми не можемо працювати з arguments як зі звичайним масивом. Для цього нам потрібно перетворити його на масив власноруч: 
// const argsArray = [...arguments]; 
// або 
// const argsArray = Array.from(arguments);


// Аргументи в стрілочних функціях
// Різниця полягає в тому, що стрілочні функції не мають свого власного об'єкта arguments. Для обробки непередбачуваної кількості аргументів у стрілочних функціях ми повинні використовувати деструктуризацію параметрів та оператор розпакування ('spread' operator), явно вказуваючи, що ми очікуємо аргументи в момент оголошення.

// Приклад:

const myFunction = (... args) => {
	console.log(args)
}

myFunction(1,2,3) // [1, 2, 3] (В цьому випадку ми вже отримуємо справжній масив)

// Також, давайте швиденько пройдемося по “залишкам” цієї теми

// Функцїя зворотнього виклику (Callback)
// Це функція, яка передається в якості аргумента іншій функції. Вона забезпечує асинхронне виконання коду, дозволяючи функції не чекати завершення іншої функції.

const callback = () => console.log("Hello");

function myFunction(callback) {
//…some code
  callback(); // Функція виконається після того, як виконається інший (попередній) код всередені основної функції. При цьому виклик колбеку не зупинить виконання іншого коду
//…some code
}

myFunction(callback); // Hello

// Анонімні функції
// Це функції які оголошуються без імені. Вони використовуються для спрощення коду та поліпшення читаємості. Але не варто їх використовувати усюди, бо це призведе до зворотнього результату.
// Приклад використання:

const button = document.querySelector('.button');

button.addEventListener('click', function() {
  // ... some code ...
});

// Асинхронні функції
// Асинхронний код, принцип його роботи і написання потребує окремої статті, але в двох словах, це функції які можуть повертати значення пізніше, ніж були викликані, а також не блокують основний потік виконання, що дозволяє іншим частинам програми продовжувати роботу, поки очікуються результати асинхронних операцій.
// Можуть бути застосовані в наступних випадках:
// -	Завантаження даних з мережі
// -	Обробка файлів
// -	Виконання складних обчислень

// Асинхронні функції, якими ви вже могли користуватись:

// -	setTimeout
// -	setInterval
// -	XMLHttpRequest
// -	fetch
// -	async/await

// Невеличкий приклад:

// за допомогою ключового слова async позначаємо, що функція буде асинхронною.

async function getData() { 
  const data = await fetch("https://api.example.com/data");
  console.log(data);
}

// За допомогою ключового слова await позначаємо, що код не може виконуватися далі, поки ми не отримуємо результат запиту.
// Тільки коли ми отримаємо результат і він запишеться в змінну, відпрацює console.log(data);

// async/await ми називаємо асинхронною функцією, але по факту вона навпаки синхронізує послідовність асинхронних операцій, роблячи код схожим на синхронний. (Як я і зазначив, ця тема потребує окремої статті)


// Функції-генератори
// Функції-генератори - це спеціальний тип функцій в JavaScript, які дозволяють генерувати послідовність значень. Я вважаю, що вони також потребують окремої статті, тому що прикладів їх використання і потреб, які вони можуть закривати, дуже багато.

// Їх особливості:

// -	Використовують ключове слово function*(з зірочкою)
// -	Можуть містити оператор yield
// -	yield використовується для паузи виконання функції та повернення значення
// Функція-генератор повертає ітератор, який можна використовувати для перебирання послідовності значень.

// Простий приклад:
function* generateNumbers() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = generateNumbers();

console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
console.log(generator.next().value); // 3

// Один з варіантів використання таких функцій це поетапне отримання даних з API, обробка даних, що надходять у міру їх отримання. Наприклад стрімінговий відео-сервіс, де отримати та відобразити великий відео файл одразу неможливо, тому ми його отримуємо частинами і підвантажуємо наступну частину тільки за потреби.


// Сподіваюся ви дізналися щось нове та у вас зʼявилося чітке розуміння різниці між видами функцій.









